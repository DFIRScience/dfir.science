---
layout: single
title: "[How to] Brute forcing password cracking devices (LUKS)"
date: '2014-08-11T16:00:00.000+09:00'

tags:
- anti-forensics
- Encryption
- HowTo
modified_time: '2015-08-24T22:35:19.193+09:00'
thumbnail: http://2.bp.blogspot.com/-WGf9KhJiN40/U9TiU7AzjFI/AAAAAAAAAzg/Zj_86E69MxE/s72-c/jtr.png
blogger_id: tag:blogger.com,1999:blog-2701259639305045003.single-5060350205287426901
blogger_orig_url: https://DFIR.Science/2014/08/how-to-brute-forcing-password-cracking.html
---

We have written in the past about how to <a href="https://DFIR.Science/2014/07/how-to-cracking-zip-and-rar-protected.html" target="_blank">crack passwords on password-protected RAR and ZIP files</a>, but in those cases someone wrote a program to extract the <i>password hashes</i>&nbsp;from the RAR and ZIP files first. After that, we could use <a href="https://DFIR.Science/2014/07/how-to-compiling-john-ripper-to-use-all.html" target="_blank">John the Ripper</a>&nbsp;to generate passwords (or use a dictionary) to attack the password hashes. In this case, John the Ripper generates a password, then hashes the password with the same hashing/salting method as the hash we are attacking. If the hash matches, then we have the clear-text password.<br /><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-WGf9KhJiN40/U9TiU7AzjFI/AAAAAAAAAzg/Zj_86E69MxE/s1600/jtr.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://2.bp.blogspot.com/-WGf9KhJiN40/U9TiU7AzjFI/AAAAAAAAAzg/Zj_86E69MxE/s1600/jtr.png" height="181" width="200" /></a></div><div>However, in some situations, we don't have a password hash to attack, or maybe we don't know what algorithm is used. Either way, we may not be able to extract a hash for whatever reason. In this case, we can still brute-force the password using the standard authentication mechanism.</div><div><br /></div><div>In this tutorial, I will be brute-force attacking a <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system" target="_blank">LUKS encrypted file</a>&nbsp;using <i>John the Ripper</i>. A LUKS encrypted file is similar to a truecrypt container. It could be used to encrypt a disk, partition, or file.</div><div><br /></div><div>Let's assume that an investigator extracted all files from a suspect disk. By looking at the file headers, we find the following:</div><div><br /><code>encrypted: LUKS encrypted file, ver 1 [aes, xts-plain64, sha1] UUID: 811f8a08-85da-4f7d-b50f-3e64ed7a66f4</code></div><br />Maybe the investigator has no memory image of the suspect device or any other information regarding the file, but still needs to get into it....<br /><br />To mount a LUKS file from the (linux) command line, you have to use <code> cryptsetup </code>. The command usually looks like <code> cryptsetup luksOpen container mountpoint </code>. When you attempt to mount, by default it will ask for a password 3 times if the attempts are incorrect. We cannot pass the password directly to cryptsetup as an option, it will always ask for a password.<br /><br />Regardless of some challenges, cryptsetup does have some useful options, such as -T which controls how many times it will ask for a password before giving up. And also the option <i>--test-passphrase</i>, which will see if the password worked without actually opening the device. So right now we have the following command to open the LUKS device:<br /><br /><code>cryptsetup luksOpen $1 x --test-passphrase -T1<br /></code><br /><br />Now we can use John the Ripper in incremental mode sending the output to standard out to generate our password list.<br /><br /><code>john -i --stdout<br /></code><br /><br />Now we just need a small script to capture the output of JtR and test the cryptsetup password:<br /><br /><code>#!/bin/bash<br /><br /># Using john the ripper to brute-force a luks container<br />startTime=$(date)<br />if [ $(file $1 | grep -c "LUKS encrypted file") ]; then<br />&nbsp; &nbsp; john -i --stdout | while read i; do<br />&nbsp; &nbsp; &nbsp; &nbsp; echo -ne "\rtrying \"$i\" "\\r<br />&nbsp; &nbsp; &nbsp; &nbsp; # as root<br />&nbsp; &nbsp; &nbsp; &nbsp; echo $i | cryptsetup luksOpen $1 x --test-passphrase -T1 2&gt; /dev/null<br />&nbsp; &nbsp; &nbsp; &nbsp; STATUS=$?<br />&nbsp; &nbsp; &nbsp; &nbsp; if [ $STATUS -eq 0 ]; then<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo -e "\nPassword is: \"$i\"<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break<br />&nbsp; &nbsp; &nbsp; &nbsp; fi<br />&nbsp; &nbsp; done<br />&nbsp; &nbsp; echo "Start time $startTime"<br />&nbsp; &nbsp; echo "End time $(date)"<br />else<br />&nbsp; &nbsp; &nbsp; &nbsp; echo "The file does not appear to be a LUKS encrypted file"<br />fi<br /></code><br /><div><br /></div><div>This bash script first uses file to check whether the input is recognized as a LUKS encrypted file. If so, it will run JtM in incremental mode, and output to stdout. A while loop is used to capture the generated password as a variable "i". We then echo the password, and pipe it to the luksOpen command. That way, when cryptsetup asks for a password it will use the password we have piped to it. The status will be either 0 if it worked or 2 if the password failed. If the status is 0, then we print the password, and how long it took. If the status is not 0, we get a new password and try again.</div><div><br /></div><div>Now, if you start to run this script you may notice that it is <b>very, very, very</b>&nbsp;slow. Generating passwords with JtM is relatively quick, but trying the passwords on a LUKS device is <i>designed to be slow</i>.</div><div><br /></div><div>This process will likely take a very long time, but 1) it will eventually crack any type of device and 2) it can be used when you have <i>no other option</i>.</div><div><br /></div><div>Try to use the script to play around with other password-protected files/devices.</div>